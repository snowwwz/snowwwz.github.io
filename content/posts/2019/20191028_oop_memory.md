---
title: "メモリの仕組みの理解はプログラマの嗜み"
date: 2019-10-28T10:20:00+09:00
draft: false
toc: false
images:
tags: 
  - dev
  - book
---

## オブジェクト指向でなぜ作るのか


「オブジェクト指向でなぜ作るのか」の第５章「メモリの仕組みの理解はプログラマのたしなみ」を読んだので、メモ。



## 一般的なメモリの使い方

- プログラムのメモリは、静的領域、ヒープ領域、スタック領域の３つに分かれて管理

**静的領域**

- プログラム開始時に確保され、以降プログラムが終了するまで配置が変わらない固定領域
- 格納されるのは、静的な変数、グローバル変数と、コード情報など

**ヒープ領域**

- 実行時に動的に確保されるメモリ領域
- heapは英語で「たくさん」の「山ほど」の意味でプログラム開始時にたくさんのメモリ領域を確保するのが由来
- 実行中にアプリケーションが必要なサイズを要求することで割り当てられ、不要になったら元に戻す使われ方

**スタック領域**
- サブルーチン（OOPではメソッド）呼び出し制御のため使われる
- タスクを終了する、または関数から抜けると、スタックの内容も破棄される。


|種類|静的領域|ヒープ領域|スタック領域|
|---|---|---|----|
|使い方|アプリケーション開始時|アプリケーション開始時に一定領域を確保。あとは都度。|LIFO|
|内容|グローバル変数、実行コード|任意（アプリケーションによる）|ローカル変数、引数、戻り値|
|確保される単位|アプリケーションでひとつ|システム、アプリケーションでひとつ|スレッドごと|

## OOPでの使われ方

- インスタンス生成時にヒープ領域が使われる=クラスのインスタンス変数を格納するのに必要なメモリが**ヒープ領域**に割り当てられる
- インスタンスを格納する変数にはインスタンスそのものではなく、ヒープ領域に作られたインスタンスの位置を示すポインタが格納される
- この時、メソッド呼び出しを実現するために、**ヒープ領域にあるインスタンスから静的領域にあるクラス情報への対応づけも行われる**


![oop_memory](/oop_memory1.png)


## メソッドテーブル

- OOPの特徴であるポリモーフィズムでは、対象となるクラスのメソッドの呼び出し方を全て統一させる必要がある。メソッドが格納されている場所を表すポインタを集めたメソッドテーブルを利用。
- メソッドテーブルは異なるクラスを同じ顔に見せるための仕組みで、実際にメソッドを呼び出す時には、このメソッドテーブルを経由して目的のメソッドを実行する。
- メソッドに書かれたコードが違っても呼び出し方法を統一できる。


![oop_memory](/oop_memory2.png)


## 継承

- スーパークラスで定義されたメソッドは、サブクラスでそのまま利用できるので、静的領域に格納されたコード情報を利用
- 継承されたメソッドのコード情報はサブクラスではメモリに展開せずスーパークラスの情報を使う
メソッドテーブルには、スーパークラスで定義されたメソッドも含めて定義される。

![oop_memory](/oop_memory3.png)

- スーパークラスで定義されたインスタンス変数はヒープ領域に作られるサブクラスの全てのインスタンスにコピーして保持される
- 全てのインスタンスに変数領域が確保されるのは、privateで宣言したインスタンス変数についても同様



